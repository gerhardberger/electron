From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Heilig Benedek <benecene@gmail.com>
Date: Mon, 21 Oct 2019 12:21:33 +0200
Subject: reuse-vp8-objects


diff --git a/third_party/blink/renderer/modules/webaudio/audio_worklet_global_scope.cc b/third_party/blink/renderer/modules/webaudio/audio_worklet_global_scope.cc
index ae1686cc67737ecbff773c3e5b500952126a01b0..471a48cd287b67b38bdbaf5a486123b9411e11b6 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_worklet_global_scope.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_worklet_global_scope.cc
@@ -172,181 +172,6 @@ AudioWorkletProcessor* AudioWorkletGlobalScope::CreateProcessor(
   return processor;
 }
 
-bool AudioWorkletGlobalScope::Process(
-    AudioWorkletProcessor* processor,
-    Vector<AudioBus*>* input_buses,
-    Vector<AudioBus*>* output_buses,
-    HashMap<String, std::unique_ptr<AudioFloatArray>>* param_value_map) {
-  CHECK_GE(input_buses->size(), 0u);
-  CHECK_GE(output_buses->size(), 0u);
-
-  ScriptState* script_state = ScriptController()->GetScriptState();
-  ScriptState::Scope scope(script_state);
-
-  v8::Isolate* isolate = script_state->GetIsolate();
-  v8::Local<v8::Context> current_context = script_state->GetContext();
-  AudioWorkletProcessorDefinition* definition =
-      FindDefinition(processor->Name());
-  DCHECK(definition);
-
-  v8::TryCatch try_catch(isolate);
-  try_catch.SetVerbose(true);
-
-  // Prepare arguments of JS callback (inputs, outputs and param_values) with
-  // directly using V8 API because the overhead of
-  // ToV8(HeapVector<HeapVector<DOMFloat32Array>>) is not negligible and there
-  // is no need to externalize the array buffers.
-
-  // 1st arg of JS callback: inputs
-  v8::Local<v8::Array> inputs = v8::Array::New(isolate, input_buses->size());
-  uint32_t input_bus_index = 0;
-  for (auto* const input_bus : *input_buses) {
-    // If |input_bus| is null, then the input is not connected, and
-    // the array for that input should have one channel and a length
-    // of 0.
-    unsigned number_of_channels = input_bus ? input_bus->NumberOfChannels() : 1;
-    size_t bus_length = input_bus ? input_bus->length() : 0;
-
-    v8::Local<v8::Array> channels = v8::Array::New(isolate, number_of_channels);
-    bool success;
-    if (!inputs
-             ->CreateDataProperty(current_context, input_bus_index++, channels)
-             .To(&success)) {
-      return false;
-    }
-    for (uint32_t channel_index = 0; channel_index < number_of_channels;
-         ++channel_index) {
-      v8::Local<v8::ArrayBuffer> array_buffer =
-          v8::ArrayBuffer::New(isolate, bus_length * sizeof(float));
-      v8::Local<v8::Float32Array> float32_array =
-          v8::Float32Array::New(array_buffer, 0, bus_length);
-      if (!channels
-               ->CreateDataProperty(current_context, channel_index,
-                                    float32_array)
-               .To(&success)) {
-        return false;
-      }
-      const v8::ArrayBuffer::Contents& contents = array_buffer->GetContents();
-      if (input_bus) {
-        memcpy(contents.Data(), input_bus->Channel(channel_index)->Data(),
-               bus_length * sizeof(float));
-      }
-    }
-  }
-
-  // 2nd arg of JS callback: outputs
-  v8::Local<v8::Array> outputs = v8::Array::New(isolate, output_buses->size());
-  uint32_t output_bus_counter = 0;
-
-  // |output_array_buffers| stores underlying array buffers so that we can copy
-  // them back to |output_buses|.
-  Vector<Vector<v8::Local<v8::ArrayBuffer>>> output_array_buffers;
-  output_array_buffers.ReserveInitialCapacity(output_buses->size());
-
-  for (auto* const output_bus : *output_buses) {
-    output_array_buffers.UncheckedAppend(Vector<v8::Local<v8::ArrayBuffer>>());
-    output_array_buffers.back().ReserveInitialCapacity(
-        output_bus->NumberOfChannels());
-    v8::Local<v8::Array> channels =
-        v8::Array::New(isolate, output_bus->NumberOfChannels());
-    bool success;
-    if (!outputs
-             ->CreateDataProperty(current_context, output_bus_counter++,
-                                  channels)
-             .To(&success)) {
-      return false;
-    }
-    for (uint32_t channel_index = 0;
-         channel_index < output_bus->NumberOfChannels(); ++channel_index) {
-      v8::Local<v8::ArrayBuffer> array_buffer =
-          v8::ArrayBuffer::New(isolate, output_bus->length() * sizeof(float));
-      v8::Local<v8::Float32Array> float32_array =
-          v8::Float32Array::New(array_buffer, 0, output_bus->length());
-      if (!channels
-               ->CreateDataProperty(current_context, channel_index,
-                                    float32_array)
-               .To(&success)) {
-        return false;
-      }
-      output_array_buffers.back().UncheckedAppend(array_buffer);
-    }
-  }
-
-  // 3rd arg of JS callback: param_values
-  v8::Local<v8::Object> param_values = v8::Object::New(isolate);
-  for (const auto& param : *param_value_map) {
-    const String& param_name = param.key;
-    const AudioFloatArray* param_array = param.value.get();
-
-    // If the AudioParam is constant, then the param array should have length 1.
-    // Manually check to see if the parameter is truly constant.
-    unsigned array_size = 1;
-
-    for (unsigned k = 1; k < param_array->size(); ++k) {
-      if (param_array->Data()[k] != param_array->Data()[0]) {
-        array_size = param_array->size();
-        break;
-      }
-    }
-
-    v8::Local<v8::ArrayBuffer> array_buffer =
-        v8::ArrayBuffer::New(isolate, array_size * sizeof(float));
-    v8::Local<v8::Float32Array> float32_array =
-        v8::Float32Array::New(array_buffer, 0, array_size);
-    bool success;
-    if (!param_values
-             ->CreateDataProperty(current_context,
-                                  V8String(isolate, param_name.IsolatedCopy()),
-                                  float32_array)
-             .To(&success)) {
-      return false;
-    }
-    const v8::ArrayBuffer::Contents& contents = array_buffer->GetContents();
-    memcpy(contents.Data(), param_array->Data(), array_size * sizeof(float));
-  }
-
-  // Perform JS function process() in AudioWorkletProcessor instance. The actual
-  // V8 operation happens here to make the AudioWorkletProcessor class a thin
-  // wrapper of v8::Object instance.
-  ScriptValue result;
-  if (!definition->ProcessFunction()
-           ->Invoke(processor, ScriptValue(script_state, inputs),
-                    ScriptValue(script_state, outputs),
-                    ScriptValue(script_state, param_values))
-           .To(&result)) {
-    // process() method call failed for some reason or an exception was thrown
-    // by the user supplied code. Disable the processor to exclude it from the
-    // subsequent rendering task.
-    processor->SetErrorState(AudioWorkletProcessorErrorState::kProcessError);
-    return false;
-  }
-
-  // Copy |sequence<sequence<Float32Array>>| back to the original
-  // |Vector<AudioBus*>|. While iterating, we also check if the size of backing
-  // array buffer is changed. When the size does not match, silence the buffer.
-  for (uint32_t output_bus_index = 0; output_bus_index < output_buses->size();
-       ++output_bus_index) {
-    AudioBus* output_bus = (*output_buses)[output_bus_index];
-    for (uint32_t channel_index = 0;
-         channel_index < output_bus->NumberOfChannels(); ++channel_index) {
-      const v8::ArrayBuffer::Contents& contents =
-          output_array_buffers[output_bus_index][channel_index]->GetContents();
-      const size_t size = output_bus->length() * sizeof(float);
-      if (contents.ByteLength() == size) {
-        memcpy(output_bus->Channel(channel_index)->MutableData(),
-               contents.Data(), size);
-      } else {
-        memset(output_bus->Channel(channel_index)->MutableData(), 0, size);
-      }
-    }
-  }
-
-  // Return the value from the user-supplied |process()| function. It is
-  // used to maintain the lifetime of the node and the processor.
-  DCHECK(!try_catch.HasCaught());
-  return result.V8Value()->IsTrue();
-}
-
 AudioWorkletProcessorDefinition* AudioWorkletGlobalScope::FindDefinition(
     const String& name) {
   return processor_definition_map_.at(name);
diff --git a/third_party/blink/renderer/modules/webaudio/audio_worklet_global_scope.h b/third_party/blink/renderer/modules/webaudio/audio_worklet_global_scope.h
index 6166e0bc986ede0bc8c277b79a3a89c78c363689..d43f2bc96357e43857963995d5b1150aae23eea9 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_worklet_global_scope.h
+++ b/third_party/blink/renderer/modules/webaudio/audio_worklet_global_scope.h
@@ -77,14 +77,6 @@ class MODULES_EXPORT AudioWorkletGlobalScope final : public WorkletGlobalScope {
       MessagePortChannel,
       scoped_refptr<SerializedScriptValue> node_options);
 
-  // Invokes the JS audio processing function from an instance of
-  // AudioWorkletProcessor, along with given AudioBuffer from the audio graph.
-  bool Process(
-      AudioWorkletProcessor*,
-      Vector<AudioBus*>* input_buses,
-      Vector<AudioBus*>* output_buses,
-      HashMap<String, std::unique_ptr<AudioFloatArray>>* param_value_map);
-
   AudioWorkletProcessorDefinition* FindDefinition(const String& name);
 
   unsigned NumberOfRegisteredDefinitions();
diff --git a/third_party/blink/renderer/modules/webaudio/audio_worklet_processor.cc b/third_party/blink/renderer/modules/webaudio/audio_worklet_processor.cc
index 8c19bd3b628a0ca9eb1b418acbfff30410329e93..e9beae6e0192d660e852295cb978623c3be85174 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_worklet_processor.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_worklet_processor.cc
@@ -4,10 +4,24 @@
 
 #include "third_party/blink/renderer/modules/webaudio/audio_worklet_processor.h"
 
+#include "third_party/blink/renderer/bindings/core/v8/idl_types.h"
+#include "third_party/blink/renderer/bindings/core/v8/native_value_traits_impl.h"
+#include "third_party/blink/renderer/bindings/core/v8/serialization/serialized_script_value.h"
+#include "third_party/blink/renderer/bindings/core/v8/to_v8_for_core.h"
+#include "third_party/blink/renderer/bindings/core/v8/v8_binding_for_core.h"
+#include "third_party/blink/renderer/bindings/core/v8/worker_or_worklet_script_controller.h"
+#include "third_party/blink/renderer/bindings/modules/v8/v8_audio_param_descriptor.h"
+#include "third_party/blink/renderer/bindings/modules/v8/v8_audio_worklet_processor.h"
+#include "third_party/blink/renderer/bindings/modules/v8/v8_blink_audio_worklet_process_callback.h"
+#include "third_party/blink/renderer/bindings/modules/v8/v8_blink_audio_worklet_processor_constructor.h"
 #include "third_party/blink/renderer/core/messaging/message_port.h"
 #include "third_party/blink/renderer/core/workers/worker_global_scope.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_buffer.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_worklet_global_scope.h"
+#include "third_party/blink/renderer/modules/webaudio/audio_worklet_processor_definition.h"
+#include "third_party/blink/renderer/platform/audio/audio_bus.h"
+#include "third_party/blink/renderer/platform/audio/audio_utilities.h"
+#include "third_party/blink/renderer/platform/bindings/callback_method_retriever.h"
 
 namespace blink {
 
@@ -39,8 +53,261 @@ bool AudioWorkletProcessor::Process(
     HashMap<String, std::unique_ptr<AudioFloatArray>>* param_value_map) {
   DCHECK(global_scope_->IsContextThread());
   DCHECK(!hasErrorOccured());
-  return global_scope_->Process(this, input_buses, output_buses,
-                                param_value_map);
+
+  CHECK_GE(input_buses->size(), 0u);
+  CHECK_GE(output_buses->size(), 0u);
+
+  ScriptState* script_state =
+      global_scope_->ScriptController()->GetScriptState();
+  ScriptState::Scope scope(script_state);
+
+  v8::Isolate* isolate = script_state->GetIsolate();
+  v8::Local<v8::Context> current_context = script_state->GetContext();
+  AudioWorkletProcessorDefinition* definition =
+      global_scope_->FindDefinition(Name());
+  DCHECK(definition);
+
+  v8::TryCatch try_catch(isolate);
+  try_catch.SetVerbose(true);
+
+  // Prepare arguments of JS callback (inputs, outputs and param_values) with
+  // directly using V8 API because the overhead of
+  // ToV8(HeapVector<HeapVector<DOMFloat32Array>>) is not negligible and there
+  // is no need to externalize the array buffers.
+
+  // 1st arg of JS callback: inputs
+  v8::Local<v8::Array> inputs = v8::Local<v8::Array>::New(isolate, inputs_);
+
+  // Check if we have already a presistent object with same length.
+  if (inputs_.IsEmpty() || inputs->Length() != input_buses->size()) {
+    // Create new persistent refernce to reuse it accross Process() calls.
+    inputs_.Reset(isolate, v8::Array::New(isolate, input_buses->size()));
+    inputs = v8::Local<v8::Array>::New(isolate, inputs_);
+  }
+
+  uint32_t input_bus_index = 0;
+  for (auto* const input_bus : *input_buses) {
+    // If |input_bus| is null, then the input is not connected, and
+    // the array for that input should have one channel and a length
+    // of 0.
+    unsigned number_of_channels = input_bus ? input_bus->NumberOfChannels() : 1;
+    size_t bus_length = input_bus ? input_bus->length() : 0;
+
+    bool success;
+    v8::Local<v8::Value> value;
+    v8::Local<v8::Array> channels;
+
+    // Check if we can reuse current object.
+    if (inputs->Get(current_context, input_bus_index).ToLocal(&value) &&
+        value->IsArray()) {
+      channels =
+          value->ToObject(current_context).ToLocalChecked().As<v8::Array>();
+    }
+    if (channels.IsEmpty() || channels->Length() != number_of_channels) {
+      channels = v8::Array::New(isolate, number_of_channels);
+
+      if (!inputs
+               ->CreateDataProperty(current_context, input_bus_index, channels)
+               .To(&success)) {
+        return false;
+      }
+    }
+    input_bus_index++;
+    for (uint32_t channel_index = 0; channel_index < number_of_channels;
+         ++channel_index) {
+      v8::Local<v8::ArrayBuffer> array_buffer;
+      v8::Local<v8::Float32Array> float32_array;
+
+      if (channels->Get(current_context, channel_index).ToLocal(&value) &&
+          value->IsFloat32Array()) {
+        float32_array = value->ToObject(current_context)
+                            .ToLocalChecked()
+                            .As<v8::Float32Array>();
+        array_buffer = float32_array->Buffer();
+      }
+      if (float32_array.IsEmpty() || float32_array->Length() != bus_length) {
+        array_buffer =
+            v8::ArrayBuffer::New(isolate, bus_length * sizeof(float));
+        float32_array = v8::Float32Array::New(array_buffer, 0, bus_length);
+
+        if (!channels
+                 ->CreateDataProperty(current_context, channel_index,
+                                      float32_array)
+                 .To(&success)) {
+          return false;
+        }
+      }
+      const v8::ArrayBuffer::Contents& contents = array_buffer->GetContents();
+      if (input_bus) {
+        memcpy(contents.Data(), input_bus->Channel(channel_index)->Data(),
+               bus_length * sizeof(float));
+      }
+    }
+  }
+
+  // 2nd arg of JS callback: outputs
+  v8::Local<v8::Array> outputs = v8::Local<v8::Array>::New(isolate, outputs_);
+
+  // Check if we have already a presistent object with same length.
+  if (outputs.IsEmpty() || outputs->Length() != output_buses->size()) {
+    // Create new persistent refernce to reuse it accross Process() calls.
+    outputs_.Reset(isolate, v8::Array::New(isolate, output_buses->size()));
+    outputs = v8::Local<v8::Array>::New(isolate, outputs_);
+  }
+
+  uint32_t output_bus_counter = 0;
+
+  // |output_array_buffers| stores underlying array buffers so that we can copy
+  // them back to |output_buses|.
+  Vector<Vector<v8::Local<v8::ArrayBuffer>>> output_array_buffers;
+  output_array_buffers.ReserveInitialCapacity(output_buses->size());
+
+  for (auto* const output_bus : *output_buses) {
+    output_array_buffers.UncheckedAppend(Vector<v8::Local<v8::ArrayBuffer>>());
+    output_array_buffers.back().ReserveInitialCapacity(
+        output_bus->NumberOfChannels());
+    bool success;
+    v8::Local<v8::Value> value;
+    v8::Local<v8::Array> channels;
+
+    // Check if we can reuse current object.
+    if (outputs->Get(current_context, output_bus_counter).ToLocal(&value) &&
+        value->IsArray()) {
+      channels =
+          value->ToObject(current_context).ToLocalChecked().As<v8::Array>();
+    }
+    if (channels.IsEmpty() ||
+        channels->Length() != output_bus->NumberOfChannels()) {
+      channels = v8::Array::New(isolate, output_bus->NumberOfChannels());
+
+      if (!outputs
+               ->CreateDataProperty(current_context, output_bus_counter,
+                                    channels)
+               .To(&success)) {
+        return false;
+      }
+    }
+    output_bus_counter++;
+    for (uint32_t channel_index = 0;
+         channel_index < output_bus->NumberOfChannels(); ++channel_index) {
+      v8::Local<v8::ArrayBuffer> array_buffer;
+      v8::Local<v8::Float32Array> float32_array;
+
+      if (channels->Get(current_context, channel_index).ToLocal(&value) &&
+          value->IsFloat32Array()) {
+        float32_array = value->ToObject(current_context)
+                            .ToLocalChecked()
+                            .As<v8::Float32Array>();
+        array_buffer = float32_array->Buffer();
+      }
+      if (float32_array.IsEmpty() ||
+          float32_array->Length() != output_bus->length()) {
+        array_buffer =
+            v8::ArrayBuffer::New(isolate, output_bus->length() * sizeof(float));
+        float32_array =
+            v8::Float32Array::New(array_buffer, 0, output_bus->length());
+
+        if (!channels
+                 ->CreateDataProperty(current_context, channel_index,
+                                      float32_array)
+                 .To(&success)) {
+          return false;
+        }
+      }
+
+      output_array_buffers.back().UncheckedAppend(array_buffer);
+    }
+  }
+
+  if (params_.IsEmpty())
+    params_.Reset(isolate, v8::Object::New(isolate));
+  // 3rd arg of JS callback: param_values
+  v8::Local<v8::Object> param_values =
+      v8::Local<v8::Object>::New(isolate, params_);
+  for (const auto& param : *param_value_map) {
+    const String& param_name = param.key;
+    const AudioFloatArray* param_array = param.value.get();
+
+    // If the AudioParam is constant, then the param array should have length 1.
+    // Manually check to see if the parameter is truly constant.
+    unsigned array_size = 1;
+
+    for (unsigned k = 1; k < param_array->size(); ++k) {
+      if (param_array->Data()[k] != param_array->Data()[0]) {
+        array_size = param_array->size();
+        break;
+      }
+    }
+    bool success;
+    v8::Local<v8::Value> value;
+    v8::Local<v8::Array> channels;
+    v8::Local<v8::ArrayBuffer> array_buffer;
+    v8::Local<v8::Float32Array> float32_array;
+
+    if (param_values
+            ->Get(current_context, V8String(isolate, param_name.IsolatedCopy()))
+            .ToLocal(&value) &&
+        value->IsFloat32Array()) {
+      float32_array = value->ToObject(current_context)
+                          .ToLocalChecked()
+                          .As<v8::Float32Array>();
+      array_buffer = float32_array->Buffer();
+    }
+    if (float32_array.IsEmpty() || float32_array->Length() != array_size) {
+      array_buffer = v8::ArrayBuffer::New(isolate, array_size * sizeof(float));
+      float32_array = v8::Float32Array::New(array_buffer, 0, array_size);
+
+      if (!param_values
+               ->CreateDataProperty(
+                   current_context,
+                   V8String(isolate, param_name.IsolatedCopy()), float32_array)
+               .To(&success)) {
+        return false;
+      }
+    }
+
+    const v8::ArrayBuffer::Contents& contents = array_buffer->GetContents();
+    memcpy(contents.Data(), param_array->Data(), array_size * sizeof(float));
+  }
+
+  // Perform JS function process() in AudioWorkletProcessor instance.
+  ScriptValue result;
+  if (!definition->ProcessFunction()
+           ->Invoke(this, ScriptValue(script_state, inputs),
+                    ScriptValue(script_state, outputs),
+                    ScriptValue(script_state, param_values))
+           .To(&result)) {
+    // process() method call failed for some reason or an exception was thrown
+    // by the user supplied code. Disable the processor to exclude it from the
+    // subsequent rendering task.
+    SetErrorState(AudioWorkletProcessorErrorState::kProcessError);
+    return false;
+  }
+
+  // Copy |sequence<sequence<Float32Array>>| back to the original
+  // |Vector<AudioBus*>|. While iterating, we also check if the size of backing
+  // array buffer is changed. When the size does not match, silence the buffer.
+  for (uint32_t output_bus_index = 0; output_bus_index < output_buses->size();
+       ++output_bus_index) {
+    AudioBus* output_bus = (*output_buses)[output_bus_index];
+    for (uint32_t channel_index = 0;
+         channel_index < output_bus->NumberOfChannels(); ++channel_index) {
+      const v8::ArrayBuffer::Contents& contents =
+          output_array_buffers[output_bus_index][channel_index]->GetContents();
+      const size_t size = output_bus->length() * sizeof(float);
+      if (contents.ByteLength() == size) {
+        memcpy(output_bus->Channel(channel_index)->MutableData(),
+               contents.Data(), size);
+      } else {
+        memset(output_bus->Channel(channel_index)->MutableData(), 0, size);
+      }
+    }
+  }
+
+  // Return the value from the user-supplied |process()| function. It is
+  // used to maintain the lifetime of the node and the processor.
+  DCHECK(!try_catch.HasCaught());
+  return result.V8Value()->IsTrue();
 }
 
 void AudioWorkletProcessor::SetErrorState(
diff --git a/third_party/blink/renderer/modules/webaudio/audio_worklet_processor.h b/third_party/blink/renderer/modules/webaudio/audio_worklet_processor.h
index e5e9aedcac02658af50f1c7f1da2ff5a49f0ecd6..f0f088a17be946996af31158f8335104b8f33d6d 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_worklet_processor.h
+++ b/third_party/blink/renderer/modules/webaudio/audio_worklet_processor.h
@@ -68,6 +68,10 @@ class MODULES_EXPORT AudioWorkletProcessor : public ScriptWrappable {
 
   AudioWorkletProcessorErrorState error_state_ =
       AudioWorkletProcessorErrorState::kNoError;
+
+  v8::UniquePersistent<v8::Array> inputs_;
+  v8::UniquePersistent<v8::Array> outputs_;
+  v8::UniquePersistent<v8::Object> params_;
 };
 
 }  // namespace blink
